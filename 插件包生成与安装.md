# 插件开发步骤
## 1. 环境搭建
### 1.1 node.js环境搭建
进入node.js官网[**下载https://nodejs.org/**](https://nodejs.org/)安装，安装完毕后打开命令行（Win+R → 输入**cmd** 点击确定 → 输入 **npm -v** 若提示版本信息则安装成功！如图  

![](https://i.imgur.com/iCHqGQd.png)

### 1.2 cordova 的安装
1、以管理员身份运行**Node.js command prompt**   

![](https://i.imgur.com/AvNnwF0.png)

2、在打开的命令行窗口中，输入以下命令：  
**npm install -g cordova**    

![](https://i.imgur.com/uD6DDT7.png)  

3、这个安装过程，取决于你的网速，我第一次安装的时候，装了好久都没有成功，当我第二天再装一遍的时候，大概10分钟左右的时候就可以完成安装了。当安装完成之后，在命令窗口中输入以下命令，来验证cordova是否安装成功：
**cordova -v**   

![](https://i.imgur.com/EpESCwp.png)  

## 2. 创建你的第一个cordova应用  
### 2.1 创建cordova工程  

**cordova create hello com.toone.hello HelloWorld**

①第一个参数hello表示在工程目录中创建一个 hello 的文件夹  
②第二个参数com.toone.hello表示包名（反向域名），用于标志不同的 app  
③第三个参数HelloWorld表示项目的名称，可以在 config.xml 文件中修改    

![](https://i.imgur.com/16DTgdU.png)

### 2.2 添加android平台
1、进入创建的目录 **cd hello**

2、添加Android平台 **cordova platform add android**   

![](https://i.imgur.com/nfDEnbk.png)

### 2.3 环境搭建完毕
1、cordova工程目录 例如：**E:\cordovaWorkplace\hello**    

![](https://i.imgur.com/VnlyFtU.png)  

2、android工程目录 例如：**E:\cordovaWorkplace\hello\platforms\android**  

![](https://i.imgur.com/sXPKTnI.png)

3、修改开发插件包的android工程配置  
①用androidstuido3.0工具打开新建的android工程。  
②替换app目录下的build.gradle文件配置。
```
apply plugin: 'com.android.application'

buildscript {
    repositories {
        mavenCentral()
        jcenter()
        google()
    }

    dependencies {
        classpath 'com.android.tools.build:gradle:3.0.0'
    }
}

// Allow plugins to declare Maven dependencies via build-extras.gradle.
allprojects {
    repositories {
        mavenCentral()
        jcenter()
        google()
    }
}

task wrapper(type: Wrapper) {
    gradleVersion = '4.1.0'
}

// Configuration properties. Set these via environment variables, build-extras.gradle, or gradle.properties.
// Refer to: http://www.gradle.org/docs/current/userguide/tutorial_this_and_that.html
ext {
    apply from: '../CordovaLib/cordova.gradle'
    // The value for android.compileSdkVersion.
    if (!project.hasProperty('cdvCompileSdkVersion')) {
        cdvCompileSdkVersion = null;
    }
    // The value for android.buildToolsVersion.
    if (!project.hasProperty('cdvBuildToolsVersion')) {
        cdvBuildToolsVersion = null;
    }
    // Sets the versionCode to the given value.
    if (!project.hasProperty('cdvVersionCode')) {
        cdvVersionCode = null
    }
    // Sets the minSdkVersion to the given value.
    if (!project.hasProperty('cdvMinSdkVersion')) {
        cdvMinSdkVersion = null
    }
    // Whether to build architecture-specific APKs.
    if (!project.hasProperty('cdvBuildMultipleApks')) {
        cdvBuildMultipleApks = null
    }
    // Whether to append a 0 "abi digit" to versionCode when only a single APK is build
    if (!project.hasProperty('cdvVersionCodeForceAbiDigit')) {
        cdvVersionCodeForceAbiDigit = null
    }
    // .properties files to use for release signing.
    if (!project.hasProperty('cdvReleaseSigningPropertiesFile')) {
        cdvReleaseSigningPropertiesFile = null
    }
    // .properties files to use for debug signing.
    if (!project.hasProperty('cdvDebugSigningPropertiesFile')) {
        cdvDebugSigningPropertiesFile = null
    }
    // Set by build.js script.
    if (!project.hasProperty('cdvBuildArch')) {
        cdvBuildArch = null
    }

    // Plugin gradle extensions can append to this to have code run at the end.
    cdvPluginPostBuildExtras = []
}

// PLUGIN GRADLE EXTENSIONS START
// PLUGIN GRADLE EXTENSIONS END

def hasBuildExtras = file('build-extras.gradle').exists()
if (hasBuildExtras) {
    apply from: 'build-extras.gradle'
}

// Set property defaults after extension .gradle files.
if (ext.cdvCompileSdkVersion == null) {
    ext.cdvCompileSdkVersion = privateHelpers.getProjectTarget()
    //ext.cdvCompileSdkVersion = project.ext.defaultCompileSdkVersion
}
if (ext.cdvBuildToolsVersion == null) {
    ext.cdvBuildToolsVersion = privateHelpers.findLatestInstalledBuildTools()
    //ext.cdvBuildToolsVersion = project.ext.defaultBuildToolsVersion
}
if (ext.cdvDebugSigningPropertiesFile == null && file('../debug-signing.properties').exists()) {
    ext.cdvDebugSigningPropertiesFile = '../debug-signing.properties'
}
if (ext.cdvReleaseSigningPropertiesFile == null && file('../release-signing.properties').exists()) {
    ext.cdvReleaseSigningPropertiesFile = '../release-signing.properties'
}

// Cast to appropriate types.
ext.cdvBuildMultipleApks = cdvBuildMultipleApks == null ? false : cdvBuildMultipleApks.toBoolean();
ext.cdvVersionCodeForceAbiDigit = cdvVersionCodeForceAbiDigit == null ? false : cdvVersionCodeForceAbiDigit.toBoolean();
ext.cdvMinSdkVersion = cdvMinSdkVersion == null ? null : defaultMinSdkVersion
ext.cdvVersionCode = cdvVersionCode == null ? null : Integer.parseInt('' + cdvVersionCode)

def computeBuildTargetName(debugBuild) {
    def ret = 'assemble'
    if (cdvBuildMultipleApks && cdvBuildArch) {
        def arch = cdvBuildArch == 'arm' ? 'armv7' : cdvBuildArch
        ret += '' + arch.toUpperCase().charAt(0) + arch.substring(1);
    }
    return ret + (debugBuild ? 'Debug' : 'Release')
}

// Make cdvBuild a task that depends on the debug/arch-sepecific task.
task cdvBuildDebug
cdvBuildDebug.dependsOn {
    return computeBuildTargetName(true)
}

task cdvBuildRelease
cdvBuildRelease.dependsOn {
    return computeBuildTargetName(false)
}

task cdvPrintProps << {
    println('cdvCompileSdkVersion=' + cdvCompileSdkVersion)
    println('cdvBuildToolsVersion=' + cdvBuildToolsVersion)
    println('cdvVersionCode=' + cdvVersionCode)
    println('cdvVersionCodeForceAbiDigit=' + cdvVersionCodeForceAbiDigit)
    println('cdvMinSdkVersion=' + cdvMinSdkVersion)
    println('cdvBuildMultipleApks=' + cdvBuildMultipleApks)
    println('cdvReleaseSigningPropertiesFile=' + cdvReleaseSigningPropertiesFile)
    println('cdvDebugSigningPropertiesFile=' + cdvDebugSigningPropertiesFile)
    println('cdvBuildArch=' + cdvBuildArch)
    println('computedVersionCode=' + android.defaultConfig.versionCode)
    android.productFlavors.each { flavor ->
        println('computed' + flavor.name.capitalize() + 'VersionCode=' + flavor.versionCode)
    }
}

android {
    defaultConfig {
        applicationId privateHelpers.extractStringFromManifest("package")
        if (cdvMinSdkVersion != null) {
            minSdkVersion cdvMinSdkVersion
        }
        minSdkVersion 19
        targetSdkVersion 23
    }
    sourceSets {
        main {
            manifest.srcFile 'src/main/AndroidManifest.xml'
            jniLibs.srcDirs = ['libs']
            res.srcDirs = ['src/main/res']
            java.srcDirs = ['src/main/java']
            assets.srcDirs = ['src/main/assets']
        }
    }
    lintOptions {
        abortOnError false;
    }
    compileSdkVersion 23
    buildToolsVersion '27.0.0'
    //This code exists for Crosswalk and other Native APIs.
    //By default, we multiply the existing version code in the Android Manifest by 10 and
    //add a number for each architecture.  If you are not using Crosswalk or SQLite, you can
    //ignore this chunk of code, and your version codes will be respected.
    if (Boolean.valueOf(cdvBuildMultipleApks)) {
        flavorDimensions "default"

        productFlavors {
            armeabi {
                versionCode defaultConfig.versionCode * 10 + 1
                ndk {
                    abiFilters = ["armeabi"]
                }
            }
            armv7 {
                versionCode defaultConfig.versionCode * 10 + 2
                ndk {
                    abiFilters = ["armeabi-v7a"]
                }
            }
            arm64 {
                versionCode defaultConfig.versionCode * 10 + 3
                ndk {
                    abiFilters = ["arm64-v8a"]
                }
            }
            x86 {
                versionCode defaultConfig.versionCode * 10 + 4
                ndk {
                    abiFilters = ["x86"]
                }
            }
            x86_64 {
                versionCode defaultConfig.versionCode * 10 + 5
                ndk {
                    abiFilters = ["x86_64"]
                }
            }
        }
    } else if (Boolean.valueOf(cdvVersionCodeForceAbiDigit)) {
        // This provides compatibility to the default logic for versionCode before cordova-android 5.2.0
        defaultConfig {
            versionCode defaultConfig.versionCode * 10
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }
    if (cdvReleaseSigningPropertiesFile) {
        signingConfigs {
            release {
                // These must be set or Gradle will complain (even if they are overridden).
                keyAlias = ""
                keyPassword = "__unset"
                // And these must be set to non-empty in order to have the signing step added to the task graph.
                storeFile = null
                storePassword = "__unset"
            }
        }
        buildTypes {
            release {
                signingConfig signingConfigs.release
            }
        }
        addSigningProps(cdvReleaseSigningPropertiesFile, signingConfigs.release)
    }
    if (cdvDebugSigningPropertiesFile) {
        addSigningProps(cdvDebugSigningPropertiesFile, signingConfigs.debug)
    }
    productFlavors {
    }
}

/*
 * WARNING: Cordova Lib and platform scripts do management inside of this code here,
 * if you are adding the dependencies manually, do so outside the comments, otherwise
 * the Cordova tools will overwrite them
 */


dependencies {
    implementation fileTree(include: '*.jar', dir: 'libs')
    // SUB-PROJECT DEPENDENCIES START
    implementation project(path: ':CordovaLib')
    // SUB-PROJECT DEPENDENCIES END
}

def promptForReleaseKeyPassword() {
    if (!cdvReleaseSigningPropertiesFile) {
        return;
    }
    if ('__unset'.equals(android.signingConfigs.release.storePassword)) {
        android.signingConfigs.release.storePassword = privateHelpers.promptForPassword('Enter key store password: ')
    }
    if ('__unset'.equals(android.signingConfigs.release.keyPassword)) {
        android.signingConfigs.release.keyPassword = privateHelpers.promptForPassword('Enter key password: ');
    }
}

gradle.taskGraph.whenReady { taskGraph ->
    taskGraph.getAllTasks().each() { task ->
      if(['validateReleaseSigning', 'validateSigningRelease', 'validateSigningArmv7Release', 'validateSigningX76Release'].contains(task.name)) {
         promptForReleaseKeyPassword()
      }
    }
}

def addSigningProps(propsFilePath, signingConfig) {
    def propsFile = file(propsFilePath)
    def props = new Properties()
    propsFile.withReader { reader ->
        props.load(reader)
    }

    def storeFile = new File(props.get('key.store') ?: privateHelpers.ensureValueExists(propsFilePath, props, 'storeFile'))
    if (!storeFile.isAbsolute()) {
        storeFile = RelativePath.parse(true, storeFile.toString()).getFile(propsFile.getParentFile())
    }
    if (!storeFile.exists()) {
        throw new FileNotFoundException('Keystore file does not exist: ' + storeFile.getAbsolutePath())
    }
    signingConfig.keyAlias = props.get('key.alias') ?: privateHelpers.ensureValueExists(propsFilePath, props, 'keyAlias')
    signingConfig.keyPassword = props.get('keyPassword', props.get('key.alias.password', signingConfig.keyPassword))
    signingConfig.storeFile = storeFile
    signingConfig.storePassword = props.get('storePassword', props.get('key.store.password', signingConfig.storePassword))
    def storeType = props.get('storeType', props.get('key.store.type', ''))
    if (!storeType) {
        def filename = storeFile.getName().toLowerCase();
        if (filename.endsWith('.p12') || filename.endsWith('.pfx')) {
            storeType = 'pkcs12'
        } else {
            storeType = signingConfig.storeType // "jks"
        }
    }
    signingConfig.storeType = storeType
}

for (def func : cdvPluginPostBuildExtras) {
    func()
}

// This can be defined within build-extras.gradle as:
//     ext.postBuildExtras = { ... code here ... }
if (hasProperty('postBuildExtras')) {
    postBuildExtras()
}
```
③替换CordovaLib目录下的build.gradle文件配置。
```

ext {
    apply from: 'cordova.gradle'
    cdvCompileSdkVersion = privateHelpers.getProjectTarget()
    cdvBuildToolsVersion = privateHelpers.findLatestInstalledBuildTools()
}
buildscript {
    repositories {
        jcenter()
        google()
    }

    dependencies {
        classpath 'com.android.tools.build:gradle:3.0.0'
        classpath 'com.github.dcendents:android-maven-gradle-plugin:1.5'
        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
    }
}
apply plugin: 'com.android.library'
apply plugin: 'com.github.dcendents.android-maven'
apply plugin: 'com.jfrog.bintray'
group = 'org.apache.cordova'
version = '7.0.0'
android {
    compileSdkVersion 23
    buildToolsVersion '27.0.0'
    publishNonDefault true
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_7
        targetCompatibility JavaVersion.VERSION_1_7
    }
    sourceSets {
        main {
            manifest.srcFile 'AndroidManifest.xml'
            java.srcDirs = ['src']
            resources.srcDirs = ['src']
            aidl.srcDirs = ['src']
            renderscript.srcDirs = ['src']
            res.srcDirs = ['res']
            assets.srcDirs = ['assets']
        }
    }
    packagingOptions {
        exclude 'META-INF/LICENSE'
        exclude 'META-INF/LICENSE.txt'
        exclude 'META-INF/DEPENDENCIES'
        exclude 'META-INF/NOTICE'
    }
    defaultConfig {
        minSdkVersion 19
        targetSdkVersion 23
    }
    productFlavors {
    }
}
install {
    repositories.mavenInstaller {
        pom {
            project {
                packaging 'aar'
                name 'Cordova'
                url 'https://cordova.apache.org'
                licenses {
                    license {
                        name 'The Apache Software License, Version 2.0'
                        url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                    }
                }
                developers {
                    developer {
                        id 'stevengill'
                        name 'Steve Gill'
                    }
                }
                scm {
                    connection 'https://git-wip-us.apache.org/repos/asf?p=cordova-android.git'
                    developerConnection 'https://git-wip-us.apache.org/repos/asf?p=cordova-android.git'
                    url 'https://git-wip-us.apache.org/repos/asf?p=cordova-android'

                }
            }
        }
    }
}
task sourcesJar(type: Jar) {
    from android.sourceSets.main.java.srcDirs
    classifier = 'sources'
}
artifacts {
    archives sourcesJar
}
bintray {
    user = System.getenv('BINTRAY_USER')
    key = System.getenv('BINTRAY_KEY')
    configurations = ['archives']
    pkg {
        repo = 'maven'
        name = 'cordova-android'
        userOrg = 'cordova'
        licenses = ['Apache-2.0']
        vcsUrl = 'https://git-wip-us.apache.org/repos/asf?p=cordova-android.git'
        websiteUrl = 'https://cordova.apache.org'
        issueTrackerUrl = 'https://issues.apache.org/jira/browse/CB'
        publicDownloadNumbers = true
        licenses = ['Apache-2.0']
        labels = ['android', 'cordova', 'phonegap']
        version {
            name = '7.0.0'
            released = new Date()
            vcsTag = '7.0.0'
        }
    }
}

dependencies {
}
```
④把app/src/main下的lib包移动到app下，如图

![](https://i.imgur.com/EJbKZPW.png)

⑤替换android目录下build.gradle文件配置
```

buildscript {
    repositories {
        jcenter()
        google()
    }
    dependencies {

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
        classpath 'com.android.tools.build:gradle:3.0.0'
    }
}

allprojects {
    repositories {
        jcenter()
        google()
    }
    //This replaces project.properties w.r.t. build settings
    project.ext {
      defaultBuildToolsVersion="27.0.0" //String
      defaultMinSdkVersion=19 //Integer - Minimum requirement is Android 4.4
      defaultTargetSdkVersion=23 //Integer - We ALWAYS target the latest by default
      defaultCompileSdkVersion=23 //Integer - We ALWAYS compile with the latest by default
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

```
⑥Builde → Clean Project

## 3. 自定义cordova插件包  
### 3.1 pluman的安装  
**npm install -g plugman**  

①如果permission denied  （try:  sudo npm install -g plugman）  
②如果ERROR 404 请检查网络  
③plugman安装是否成功检查 plugman -v

![](https://i.imgur.com/ZhkPpGD.png)

### 3.2 plugman安装完后创建一个插件包

**plugman create --name <font color=#22B14C>pluginName</font> --plugin_id <font color=#22B14C>pluginID</font> --plugin_version <font color=#22B14C>version</font> [--path <font color=#22B14C>directory</font>] [--variable <font color=#22B14C>NAME=VALUE</font>]**

①pluginName: 插件名字  
②pluginID: 插件id  
③version: 版本  
④directory:一个绝对或相对路径的目录，该目录将创建插件项目  
⑤NAME=VALUE: 额外的描述，如作者信息和相关描述

例如 : **plugman create --name ToonePlugin --plugin_id toonePlugin --plugin_version 1.0.0**

**当前目录生成的插件包：**  

![](https://i.imgur.com/qMpOgX4.png)  

**插件包目录：**  

![](https://i.imgur.com/NMw9o9K.png)  

### 3.3 在插件包中添加android平台  
 **plugman platform add --platform_name  android**    

![](https://i.imgur.com/MMPsUAi.png)  

### 3.4 plugin.xml 文件（以下以官方cordova-plugin-app-version插件作为测试案例）  
```xml
<?xml version="1.0" encoding="UTF-8"?>
<plugin xmlns="http://www.phonegap.com/ns/plugins/1.0"
    xmlns:android="http://schemas.android.com/apk/res/android"
    id="cordova-plugin-app-version"
    version="0.1.9">

    <name>AppVersion</name>
    <description>
        This plugin will return the version of your App that you have set in
        packaging it. I.e. it will always match the version in the app store.
    </description>
    <license>MIT</license>

    <engines>
        <!--
            Cordova 2.8.0 is all I have tested on - it should work fine with earlier versions.
            Please modify the below line, test, and submit a PR if it works for you.
        -->
        <engine name="cordova" version=">=3.0.0" />
    </engines>

    <js-module src="www/AppVersionPlugin.js">
       <clobbers target="cordova.getAppVersion" />
    </js-module>

    <!-- android -->
    <platform name="android">
        <config-file target="res/xml/config.xml" parent="/*">
            <feature name="AppVersion">
                <param name="android-package" value="uk.co.whiteoctober.cordova.AppVersion"/>
            </feature>
        </config-file>
        <source-file src="src/android/AppVersion.java" target-dir="src/uk/co/whiteoctober/cordova" />
    </platform>

    <!-- ios -->
    <platform name="ios">
        <plugins-plist key="AppVersion" string="AppVersion" />

        <config-file target="config.xml" parent="/*">
            <feature name="AppVersion">
                <param name="ios-package" value="AppVersion" />
            </feature>
        </config-file>

        <header-file src="src/ios/AppVersion.h" />
        <source-file src="src/ios/AppVersion.m" />
    </platform>
</plugin>
```

### 3.5 AppVersionPlugin.js 文件  
```js
/*jslint indent: 2 */
/*global window, jQuery, angular, cordova */
"use strict";

// Returns a jQuery or AngularJS deferred object, or pass a success and fail callbacks if you don't want to use jQuery or AngularJS
var getPromisedCordovaExec = function (command, success, fail) {
  var toReturn, deferred, injector, $q;
  if (success === undefined) {
    if (window.jQuery) {
      deferred = jQuery.Deferred();
      success = deferred.resolve;
      fail = deferred.reject;
      toReturn = deferred;
    } else if (window.angular) {
      injector = angular.injector(["ng"]);
      $q = injector.get("$q");
      deferred = $q.defer();
      success = deferred.resolve;
      fail = deferred.reject;
      toReturn = deferred.promise;
    } else if (window.when && window.when.promise) {
      deferred = when.defer();
      success = deferred.resolve;
      fail = deferred.reject;
      toReturn = deferred.promise;
    } else if (window.Promise) {
      toReturn = new Promise(function(c, e) {
        success = c;
        fail = e;
      });
    } else if (window.WinJS && window.WinJS.Promise) {
      toReturn = new WinJS.Promise(function(c, e) {
        success = c;
        fail = e;
      });
    } else {
      return console.error('AppVersion either needs a success callback, or jQuery/AngularJS/Promise/WinJS.Promise defined for using promises');
    }
  }
  // 5th param is NOT optional. must be at least empty array
  cordova.exec(success, fail, "AppVersion", command, []);
  return toReturn;
};

var getAppVersion = function (success, fail) {
  return getPromisedCordovaExec('getVersionNumber', success, fail);
};

getAppVersion.getAppName = function (success, fail) {
  return getPromisedCordovaExec('getAppName', success, fail);
};

getAppVersion.getPackageName = function (success, fail) {
  return getPromisedCordovaExec('getPackageName', success, fail);
};

getAppVersion.getVersionNumber = function (success, fail) {
  return getPromisedCordovaExec('getVersionNumber', success, fail);
};

getAppVersion.getVersionCode = function (success, fail) {
  return getPromisedCordovaExec('getVersionCode', success, fail);
};

module.exports = getAppVersion;

```
### 3.6 AppVersion.java 文件  

```java
package uk.co.whiteoctober.cordova;

import org.apache.cordova.CordovaPlugin;
import org.apache.cordova.CallbackContext;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.pm.PackageManager;

public class AppVersion extends CordovaPlugin {
  @Override
  public boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException {

    try {
      if (action.equals("getAppName")) {
        PackageManager packageManager = this.cordova.getActivity().getPackageManager();
        ApplicationInfo app = packageManager.getApplicationInfo(this.cordova.getActivity().getPackageName(), 0);
        callbackContext.success((String)packageManager.getApplicationLabel(app));
        return true;
      }
      if (action.equals("getPackageName")) {
        callbackContext.success(this.cordova.getActivity().getPackageName());
        return true;
      }
      if (action.equals("getVersionNumber")) {
        PackageManager packageManager = this.cordova.getActivity().getPackageManager();
        callbackContext.success(packageManager.getPackageInfo(this.cordova.getActivity().getPackageName(), 0).versionName);
      return true;
      }
      if (action.equals("getVersionCode")) {
        PackageManager packageManager = this.cordova.getActivity().getPackageManager();
        callbackContext.success(packageManager.getPackageInfo(this.cordova.getActivity().getPackageName(), 0).versionCode);
      return true;
      }
      return false;
    } catch (NameNotFoundException e) {
      callbackContext.success("N/A");
      return true;
    }
  }
}
```

- 其中java文件要继承CordovaPlugin并重写execute，根据action执行指定任务并通过callbackContext返回数据到前端

### 3.7 将准备好的插件包在cordova环境下安装到android工程中
1、样例插件包路径为：E:\cordovaWorkplace\cordovaPlugin\ToonePlugin

![](https://i.imgur.com/QC1Kk1O.png)

2、将开发好的插件资源文件进行替换，如图

![](https://i.imgur.com/VNVPhC8.png)

3、在插件包中自动生成package.json  

 **plugman createpackagejson E:\cordovaWorkplace\cordovaPlugin\ToonePlugin**  

![](https://i.imgur.com/Crdc8Pn.png)

4、在cordova工程环境中（Shift+鼠标右键）点击在此处打开命令窗口，如图  

![](https://i.imgur.com/mR8HY02.png)

5、执行插件安装命令 **cordova add [ git地址/本地磁盘目录/cordova服务器上的插件id ]**

例如： **cordova plugin add E:\cordovaWorkplace\cordovaPlugin\ToonePlugin**  

![](https://i.imgur.com/iVQFk2Y.png)  

6、卸载插件 **cordova plugin remove [ plugin_id ]**  

例如：**cordova plugin remove cordova-plugin-app-version**  

![](https://i.imgur.com/Hv00xkb.png)

7、查看已安装的cordova插件列表  

例如：**cordova plugin list**

![](https://i.imgur.com/vDcttnC.png)

### 3.8 简单调用测试
1、在assets/www/js/index.js文件中替换以下代码：
```js
onDeviceReady: function() {
       this.receivedEvent('deviceready');

       var success = function(data){
           console.log("appName = " + data);
       }
       cordova.getAppVersion.getAppName(success);
   },
```
运行输出:
```
com.toone.hello I/chromium: [INFO:CONSOLE(49)] "Received Event: deviceready", source: file:///android_asset/www/js/index.js (49)
com.toone.hello I/chromium: [INFO:CONSOLE(33)] "appName = HelloWorld", source: file:///android_asset/www/js/index.js (33)
```

**注：** 配置好的插件包开发环境工程下载地址：[https://github.com/nihaohebin/CordovaPluginDevelopment.git](https://github.com/nihaohebin/CordovaPluginDevelopment.git)
